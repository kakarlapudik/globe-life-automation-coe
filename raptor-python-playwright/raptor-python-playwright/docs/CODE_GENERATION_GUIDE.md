# Code Generation Tools Guide

This guide covers the RAPTOR code generation tools that help you automatically generate page objects, test templates, and suggest optimal locators.

## Overview

The code generation tools include:

1. **Page Object Generator** - Generates Python page object classes from DDFE element definitions
2. **Test Template Generator** - Creates pytest test templates from test scenarios
3. **Locator Suggester** - Suggests optimal locators for web elements
4. **Code Formatter** - Formats generated code using Black, autopep8, or YAPF

## Page Object Generator

### Basic Usage

```python
from raptor.codegen.page_object_generator import (
    PageObjectGenerator,
    ElementDefinition
)

# Define elements
elements = [
    ElementDefinition(
        pv_name="UsernameField",
        application_name="Login",
        field_type="textbox",
        locator_primary="css=#username",
        locator_fallback1="xpath=//input[@name='username']"
    ),
    ElementDefinition(
        pv_name="LoginButton",
        application_name="Login",
        field_type="button",
        locator_primary="role=button, name=Login"
    )
]

# Generate page object
generator = PageObjectGenerator()
page_object = generator.generate_page_object(
    application_name="Login",
    elements=elements,
    base_url="https://example.com/login"
)

# Access generated code
print(page_object.code)
print(f"Class: {page_object.class_name}")
print(f"File: {page_object.file_name}")
```

### Generated Page Object Structure

The generator creates a complete page object class with:

- **Locator methods** - Methods that return Playwright locators
- **Interaction methods** - Methods for clicking, filling, selecting, etc.
- **Visibility checks** - Methods to check element visibility
- **Table operations** - Special methods for table elements
- **Proper imports** - All necessary imports included
- **Type hints** - Full type annotations
- **Docstrings** - Comprehensive documentation

### Element Type Support

The generator handles different element types:

| Element Type | Generated Methods |
|--------------|-------------------|
| button, link | `get_*_locator()`, `click_*()`, `is_*_visible()` |
| textbox, input | `get_*_locator()`, `fill_*()`, `get_*_value()`, `is_*_visible()` |
| dropdown, select | `get_*_locator()`, `select_*()`, `is_*_visible()` |
| checkbox | `get_*_locator()`, `check_*()`, `is_*_checked()`, `is_*_visible()` |
| table | `get_*_locator()`, `find_*_row()`, `get_*_cell_value()`, `is_*_visible()` |

### Fallback Locators

The generator automatically includes fallback locators:

```python
element = ElementDefinition(
    pv_name="SubmitButton",
    application_name="Form",
    field_type="button",
    locator_primary="css=#submit",
    locator_fallback1="xpath=//button[@type='submit']",
    locator_fallback2="text=Submit"
)
```

Generated code:
```python
async def get_submit_button_locator(self) -> Locator:
    """Get locator for SubmitButton."""
    return await self.element_manager.locate_element(
        "css=#submit",
        fallback_locators=["xpath=//button[@type='submit']", "text=Submit"]
    )
```

### Generating Multiple Page Objects

```python
# Group elements by application
elements_by_app = {
    "Login": [login_elements],
    "Dashboard": [dashboard_elements],
    "Settings": [settings_elements]
}

# Generate all page objects
from pathlib import Path

output_dir = Path("raptor/pages/generated")
page_objects = generator.generate_multiple_page_objects(
    elements=all_elements,
    output_dir=output_dir
)

# Also generates __init__.py
generator.generate_init_file(page_objects, output_dir / "__init__.py")
```

## Test Template Generator

### Basic Usage

```python
from raptor.codegen.test_template_generator import (
    TestTemplateGenerator,
    TestScenario,
    TestType
)

# Define test scenario
scenario = TestScenario(
    name="verify_successful_login",
    description="Verify user can login with valid credentials",
    test_type=TestType.FUNCTIONAL,
    page_object="LoginPage",
    steps=[
        "Navigate to login page",
        "Enter valid username",
        "Enter valid password",
        "Click login button"
    ],
    assertions=[
        "User is redirected to dashboard",
        "Welcome message is displayed"
    ],
    tags=["login", "smoke"]
)

# Generate test file
generator = TestTemplateGenerator()
test_file = generator.generate_test_file(
    page_object_name="LoginPage",
    scenarios=[scenario],
    include_fixtures=True
)

print(test_file.code)
```

### Generated Test Structure

```python
"""
Tests for LoginPage.

This test file was auto-generated by RAPTOR TestTemplateGenerator.
"""

import pytest
from playwright.async_api import Page, expect
from raptor.pages.login_page import LoginPage

@pytest.fixture
async def browser():
    """Provide a browser instance for tests."""
    # ... fixture code ...

@pytest.mark.login
@pytest.mark.smoke
@pytest.mark.asyncio
async def test_verify_successful_login(login_page):
    """
    Verify user can login with valid credentials
    
    Steps:
    - Navigate to login page
    - Enter valid username
    - Enter valid password
    - Click login button
    
    Assertions:
    - User is redirected to dashboard
    - Welcome message is displayed
    """
    # Arrange
    page_object = login_page
    
    # Act
    # Step 1: Navigate to login page
    # TODO: Implement step 1
    
    # Assert
    # Assertion 1: User is redirected to dashboard
    # TODO: Implement assertion 1
```

### Test Types

The generator supports different test types:

- **SMOKE** - Quick smoke tests
- **FUNCTIONAL** - Functional tests
- **REGRESSION** - Regression tests
- **DATA_DRIVEN** - Data-driven tests
- **E2E** - End-to-end tests

### Generating Smoke Test Suite

```python
# Generate smoke tests for multiple pages
page_objects = ["LoginPage", "DashboardPage", "SettingsPage"]

test_files = generator.generate_smoke_test_suite(
    page_objects=page_objects,
    output_dir=Path("tests/smoke")
)
```

### Data-Driven Tests

```python
test_file = generator.generate_data_driven_test(
    page_object_name="LoginPage",
    test_name="verify_login_with_multiple_users",
    test_data_source="database",
    steps=[
        "Load user data from database",
        "Login with each user",
        "Verify successful login"
    ]
)
```

### Generating conftest.py

```python
generator.generate_conftest(
    output_path=Path("tests/conftest.py"),
    include_database=True,
    include_config=True
)
```

## Locator Suggester

### Basic Usage

```python
from raptor.codegen.locator_suggester import (
    LocatorSuggester,
    ElementInfo
)

# Define element information
element_info = ElementInfo(
    tag_name="button",
    id="submit-btn",
    classes=["btn", "btn-primary"],
    text="Submit Form",
    role="button",
    aria_label="Submit the form",
    test_id="submit-button"
)

# Get suggestions
suggester = LocatorSuggester()
suggestions = suggester.suggest_locators(element_info, max_suggestions=5)

# Display suggestions
for suggestion in suggestions:
    print(f"Strategy: {suggestion.strategy.value}")
    print(f"Priority: {suggestion.priority.name}")
    print(f"Confidence: {suggestion.confidence:.0%}")
    print(f"Locator: {suggestion.locator}")
    print(f"Playwright: {suggestion.playwright_syntax}")
    print(f"Reason: {suggestion.reason}")
    print()
```

### Locator Strategies

The suggester prioritizes locators in this order:

1. **Role-based** (EXCELLENT) - Accessibility-first approach
   ```python
   page.get_by_role("button", name="Submit")
   ```

2. **Test ID** (EXCELLENT) - Test-specific identifiers
   ```python
   page.get_by_test_id("submit-button")
   ```

3. **ID** (GOOD) - Unique element IDs
   ```python
   page.locator("#submit-btn")
   ```

4. **Text** (GOOD) - Visible text content
   ```python
   page.get_by_text("Submit Form", exact=True)
   ```

5. **CSS** (ACCEPTABLE) - CSS selectors
   ```python
   page.locator("button.btn.btn-primary")
   ```

6. **XPath** (POOR) - XPath expressions (last resort)
   ```python
   page.locator("xpath=//button[@id='submit-btn']")
   ```

### Priority Levels

- ðŸŸ¢ **EXCELLENT** - Highly recommended, stable and maintainable
- ðŸŸ¡ **GOOD** - Recommended, reliable
- ðŸŸ  **ACCEPTABLE** - Acceptable but not ideal
- ðŸ”´ **POOR** - Not recommended, use only as last resort

### Generating Locator Report

```python
report = suggester.generate_locator_report(suggestions)
print(report)
```

Output:
```
Locator Suggestions
==================================================

1. ðŸŸ¢ ROLE
   Locator: role=button, name=Submit the form
   Priority: EXCELLENT
   Confidence: 95%
   Reason: Accessibility-first approach using ARIA role and name
   Playwright: page.get_by_role("button", name="Submit the form")
   Example: await page.get_by_role("button", name="Submit the form").click()

2. ðŸŸ¢ TEST_ID
   Locator: test_id=submit-button
   Priority: EXCELLENT
   Confidence: 90%
   Reason: Test-specific identifier, stable and reliable
   Playwright: page.get_by_test_id("submit-button")
   Example: await page.get_by_test_id("submit-button").click()
```

## Code Formatter

### Basic Usage

```python
from raptor.codegen.code_formatter import (
    CodeFormatter,
    FormatterConfig,
    FormatterType
)

# Create formatter
formatter = CodeFormatter(
    FormatterConfig(
        formatter_type=FormatterType.BLACK,
        line_length=88,
        skip_string_normalization=False
    )
)

# Format code
unformatted_code = """
def   hello(  ):
    print(  "Hello"  )
"""

result = formatter.format_code(unformatted_code, sort_imports=True)

if result.success:
    print(result.formatted_code)
    print(f"Changes made: {result.changes_made}")
else:
    print(f"Error: {result.error_message}")
```

### Supported Formatters

1. **Black** (default) - The uncompromising Python code formatter
2. **autopep8** - Automatically formats Python code to conform to PEP 8
3. **YAPF** - Yet Another Python Formatter
4. **isort** - Import sorting (used with any formatter)

### Formatting Files

```python
from pathlib import Path

# Format single file
result = formatter.format_file(
    file_path=Path("raptor/pages/login_page.py"),
    in_place=True,
    sort_imports=True
)

# Format multiple files
files = [
    Path("raptor/pages/login_page.py"),
    Path("raptor/pages/dashboard_page.py"),
    Path("raptor/pages/settings_page.py")
]

results = formatter.format_multiple_files(
    file_paths=files,
    in_place=True,
    sort_imports=True
)

for file_path, result in results.items():
    print(f"{file_path}: {'âœ“' if result.success else 'âœ—'}")
```

### Checking Available Formatters

```python
# Check if specific formatter is available
if formatter.is_formatter_available(FormatterType.BLACK):
    print("Black is available")

# Get all available formatters
available = formatter.get_available_formatters()
print(f"Available formatters: {[f.value for f in available]}")
```

### Formatter Configuration

```python
config = FormatterConfig(
    formatter_type=FormatterType.BLACK,
    line_length=100,  # Custom line length
    skip_string_normalization=True,  # Keep quote style
    target_version="py38",  # Target Python version
    additional_args=["--fast"]  # Additional arguments
)

formatter = CodeFormatter(config)
```

## Complete Workflow Example

Here's a complete workflow that uses all code generation tools:

```python
from pathlib import Path
from raptor.codegen import (
    PageObjectGenerator,
    TestTemplateGenerator,
    LocatorSuggester,
    CodeFormatter,
    ElementDefinition,
    ElementInfo,
    TestScenario,
    TestType
)

# Step 1: Analyze element and suggest optimal locator
element_info = ElementInfo(
    tag_name="button",
    id="login-submit",
    role="button",
    text="Sign In",
    test_id="login-button"
)

suggester = LocatorSuggester()
suggestions = suggester.suggest_locators(element_info, max_suggestions=1)
best_locator = suggestions[0].locator

# Step 2: Generate page object with suggested locator
element = ElementDefinition(
    pv_name="LoginButton",
    application_name="Login",
    field_type="button",
    locator_primary=best_locator
)

page_generator = PageObjectGenerator()
page_object = page_generator.generate_page_object("Login", [element])

# Step 3: Generate test template
scenario = TestScenario(
    name="verify_login_button_click",
    description="Verify login button can be clicked",
    test_type=TestType.SMOKE,
    page_object="LoginPage",
    steps=["Click login button"],
    assertions=["Button is clicked successfully"],
    tags=["smoke"]
)

test_generator = TestTemplateGenerator()
test_file = test_generator.generate_test_file("LoginPage", [scenario])

# Step 4: Format all generated code
formatter = CodeFormatter()

page_result = formatter.format_code(page_object.code)
test_result = formatter.format_code(test_file.code)

# Step 5: Write to files
output_dir = Path("generated")
output_dir.mkdir(exist_ok=True)

(output_dir / page_object.file_name).write_text(page_result.formatted_code)
(output_dir / test_file.file_name).write_text(test_result.formatted_code)

print("âœ… Code generation complete!")
```

## Best Practices

### Page Object Generation

1. **Use descriptive PV names** - They become method names
2. **Provide fallback locators** - Improves reliability
3. **Group elements by application** - Better organization
4. **Include table metadata** - For table operations
5. **Set base URLs** - For navigation methods

### Test Template Generation

1. **Write clear descriptions** - They become docstrings
2. **Use appropriate test types** - Helps with organization
3. **Add relevant tags** - For test filtering
4. **Include detailed steps** - Guides implementation
5. **Specify clear assertions** - Defines success criteria

### Locator Suggestion

1. **Prefer role-based locators** - Best for accessibility
2. **Use test-id for dynamic content** - Most stable
3. **Avoid XPath when possible** - Hard to maintain
4. **Check confidence scores** - Higher is better
5. **Review suggestions** - Don't blindly use first result

### Code Formatting

1. **Format after generation** - Ensures consistency
2. **Sort imports** - Better organization
3. **Use Black by default** - Industry standard
4. **Configure line length** - Match project standards
5. **Format in-place** - Update files directly

## Troubleshooting

### Formatter Not Available

If formatters are not available:

```bash
# Install Black
pip install black

# Install autopep8
pip install autopep8

# Install YAPF
pip install yapf

# Install isort
pip install isort
```

### Invalid Element Definitions

Validate elements before generation:

```python
from raptor.migration.ddfe_validator import DDFEValidator

validator = DDFEValidator()
result = validator.validate_element(element)

if not result.is_valid:
    for issue in result.issues:
        print(f"{issue.severity.value}: {issue.message}")
```

### Generated Code Errors

If generated code has errors:

1. Check element definitions are complete
2. Verify locator syntax is correct
3. Ensure field types are valid
4. Format code after generation
5. Run tests to validate

## See Also

- [Migration Utilities Guide](MIGRATION_UTILITIES_GUIDE.md)
- [CLI Guide](CLI_GUIDE.md)
- [Page Object Guide](BASE_PAGE_QUICK_REFERENCE.md)
- [Test Execution Guide](TEST_EXECUTION_CONTROL_GUIDE.md)
